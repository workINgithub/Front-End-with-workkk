# V8

暂时还达不到看V8源码的程度 因此借鉴了些大牛的文章。初窥下V8

[V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道(HIGO 团队)](https://juejin.im/post/5dc4d823f265da4d4c202d3b)

![V8的工作图](https://user-gold-cdn.xitu.io/2019/11/8/16e48ec4395d10ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


#### 解析器

Lazy-parsing  因为 某些例如 事件处理程序 不需要被完全解析。

> 预解析会检查源代码的语法并抛出语法错误，但不会解析函数中变量的作用域或生成 AST。完全解析则将分析函数体并生成源代码对应的 AST 数据结构。相比正常解析，预解析的速度快了 2 倍。
> 生成AST两个阶段 **分词 和 语义分析**
> AST 旨在通过一种结构化的树形数据结构来描述源代码的具体语法组成，常用于语法检查（静态代码分析）、代码混淆、代码优化等。

#### Ignirion基线编译器和字节码

> V8通过引入JIT(Just In Time)技术,通过 Ignition 基线编译器快速生成字节码进行执行。
> 字节码是机器码的抽象。如果字节码的设计与物理 CPU 的计算模型相同，那么将字节码编译成机器代码就会更加容易。这就是为什么解释器通常是寄存器或堆栈机器。Ignition 是一个带有累加器的**寄存器**。
> 和之前的基线编译器 Full-Codegen 相比，Ignition 生成的是体积更小的字节码（Full-Codegen 生成的是机器码）。字节码可以直接被优化编译器 TurboFan 用于生成图（TurboFan 对代码的优化基于图），避免优化编译器在优化代码时需要对 JavaScript 源代码重新进行解析。

#### TurboFan优化编译器 与 优化与去优化

这里有个前提，编译器需要考虑的函数输入类型变化越少 ， 生成的代码越小越快。

那我们都知道 JS是弱语言类型，操作符+ 可以操作很多类型的变量。

> 但这并不意味着 JavaScript 代码没有办法被优化。对于特定的程序逻辑，其接收的参数往往是类型固定的。正因为如此，V8 引入了类型反馈技术。在进行运算的时候，V8 使用**类型反馈**对所有参数进行动态检查。

> 简单的来说，对于重复执行的代码，如果多次传入的参数都是固定的类型，那么V8会假设这段代码在后面的一段事件也是会有相同的情况，对其进行优化。**优化后的代码中会保留基本的类型检查。**如果之后的每次执行参数类型未改变，V8 将一直执行优化过的代码。而当之后某一次执行时传入的参数类型发生变化时，**V8 将会“撤销”之前的优化操作，这一步称为“去优化”**

#### 垃圾回收


V8 的垃圾回收主要有三个阶段：标记、清除和整理

> 世代假说（generational hypothesis），也称为弱分代假说（weak generational hypothesis）。这个假说表明，大多数新生的对象在分配之后就会死亡（“用后即焚”），而老的对象通常倾向于永生。

V8基于这个假说 ， 把内存分为 新生代 和老生代
又从逻辑上 把新生代分为 Nursery婴儿期 和 Intermediate 子世代

1. 新生代
> V8 使用 Parallel Scavenge（并行清理）算法，它与 Halstead 算法类似（在 V8 v6.2 版本之前使用的是类 Cheney 算法），其核心是复制算法。

[Scavenge](https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-7)

总结：用空间换时间

from 空间(变量存放) - to 空间(清除空间，我自己称呼的)
* 把from里活跃的变量移到 to空间中
* 删除from空间里的变量
* 然后把to空间跟from空间调换一下(其实就是换个名字)


2. 老生代(由新生代 晋升promotion 过来)

两种晋升路径
> * 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。
> * 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。


**标记清除**

> 标记清除已经诞生了半个多世纪。它的算法原理十分简单。垃圾回收器从根节点开始，标记根直接引用的对象，然后递归标记这些对象的直接引用对象。对象的可达性作为是否“存活”的依据。

**标记整理**

整理内存,标记整理算法的优缺点都十分明显。它的优点是，能够让堆利用更加充分有效。它的缺点是，它需要额外的扫描时间和对象移动时间，并且花费的时间与堆的大小成正比。

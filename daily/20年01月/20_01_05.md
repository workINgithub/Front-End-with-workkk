# 2020年01月05日 学习日记

#### 函数作用域（上下文环境）复习
  函数作用域中有AO，this，作用域链[\[scope]]

#### 简单了解了下JS引擎的自动垃圾收集机制
  自动垃圾收集机制的原理：找到不再继续使用的变量，然后释放其内存空间
  两种方式（标记清除，引用计数）
  * 标记清除：**红宝书原文，当变量进入环境时（例如在函数中声明一个变量），就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存。而当变量离开环境时，则将其标记为“离开环境”**
  * 引用计数： **跟踪记录每个值被引用的次数，当这个值的引用次数变为0时，则说明没有办法在访问这个值了，因而就可以将其占用的内存空间回收回来** （循环引用问题）
  释放内存的方法：一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。具体可以看红宝书p81的例子。

#### 关系操作符和相等不相等操作符
  在我看来，这里面比较规则很多。我总结一点就是JS偏爱数值类的比较但这种情况是两个变量不是同类型。红宝书中也涵盖了很多特殊情况，例如比较时null == undefined为true，null和undefined在相等或不等操作符中不转换等。
  两个字符串在比较过程中，通过字符串对应的字符编码值进行比较。所以'200'<'30' == true

#### RegExp正则
  正则声明同对象一样。字面量声明和使用构造函数均可。
  字面量声明: /pattern/flags
  这个正则对象有以下属性：
  global: 是否有全局匹配标记
  ignoreCase: 是否有忽略大小写标记
  mutiline: 是否有多行匹配标记
  lastIndex: 开始位置
  source: 按照字面量形式传入
  有两个常用方法exec,test。前者用来捕获字符组与string的match方法很相似，后者用来测试字符串的匹配程度
  **复习过程中发现自己忘了^（脱字符）在[]中表示非的意思**

#### Function
  function 也可以通过new Function来声明，不好用，但是可以理解function也是对象实际上
  Function构造函数,Function.\prototype.\__proto == Object.prototype
  那函数是个对象，其实更可以理解，函数名就是个指针，所以 函数重载是不可能的。
  
# 2020年2月12日 学习日记

#### promise

今天同学问了两个关于promise的问题 都答错了。

看来自己对promise的理解还是肤浅了
假设fulfilledPromise 是个状态是fulfilled的promise对象
1. 
```
fulfilledPromise.then(function () {
   return new Error('')
 } ) .then (function () {} , function () {}).catch(function () {})
```

这题我不假思索就回到catch捕获里，我有忽视了链式调用的过程。

2. 
```
Promise.resolve(1).then(2).then(console.log);
```

值穿透的问题。


#### leetcode: 136 只出现一次的数字

要求时间复杂度是 线性的复杂度。那我就简单的想到了是 空间换时间
通过对象，存储数组中重复的数值。

那翻了下对象这中哈希结构的数据

> 哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。

```
let o = {
  a: 'a'
}

```

例如对象o  他有对象key a 对应value 'a'
那么这个属性存储的位置 可能就是 fn(a) 也就是物理内存地址
这个fn过程可能是：key键名在ASCII表上的对应值取余的过程

那么假如o里有太多的属性里 导致有某两个属性 内存地址相同。

* 开放地址法 开放定址法就是产生冲突之后去寻找下一个空闲的空间。
* 链表法 另外一种类型解决冲突的办法，散列到同一位置的元素，不是继续往下探测，而是在这个位置是一个链表，这些元素则都放到这一个链表上
# 20年04月周记

那从4月开始我想变个花样，把学习日记的形式改为周记。

原因有以下:

1. 周记每月有四次，减少了写记录的频率。这样能汇总更多的内容，也方便说下次回顾。但实际上还是每天都有记录。
2. 有些学习内容可能是分两天学习的，那写在一篇周记里，可能会更加完整，方便阅读。

**两个链表的第一个公共节点**

1. 使用哈希表

使用map记录某一条链表的每个节点，然后拿第二条链表的每一个节点去比对。

时间复杂度O(m*n), 空间复杂度O(n)

2. 遍历两个链表

的确，两个链表的长度不一定相同。但是如果，我们把两个链表拼接在一起，它们的长度必然是相同的。

假设链表a, 链表b, 使用两个指针遍历a + b, 和 b + a。

假设没有交点，最后指针同时指向null

假设有交点, 因为两条遍历顺序 长度相同，也就是说两条拼接链表的尾节点对齐了，那么必然在遍历的过程中是会遇到公共节点的

我仔细想了想，这种方法还是通过尾部对齐，也就是说，指针必然在遍历的过程中，指向相同的两个交点或是null。

具体可以画图

3. 建立双向链表

思路我觉得和上一个挺像的，就是把尾部对齐，从尾部开始遍历。


**二叉树展开为链表**

还是用递归的思想去做。(这个展开过程就是先序遍历)

fn函数 作用

如果左子树存在，把左子树插到右边，并调用fn处理左子树

如果右子树存在，把右子树插到左子树的右子树上，并调用fn处理右子树

返回这个节点的最后一个节点

**二进制的个数**

js数实际上是32位精度，也就是1位符号位(0代表正数1代表负数)，另外31个都是表示数值。那计算下 2^30 + 2^29 + ... + 2^0 = 2^31 - 1;

& 操作，有0则返回0， 只有两个1才返回1

通过这个性质，我们可以判断某一位是否是1，然后统计并返回结果

因为有32位，可以遍历32次

假设flag是判断的数值  利用位操作 << ，可以不断的去变化。

例如 flag = 1, "000000...1"
flag = 2, "00000000..10"
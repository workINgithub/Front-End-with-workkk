# 20年4月周记 2

#### CORS问题

做毕设的时候遇到的问题,遇到跨域问题了。采用CORS解决，复习一下这个过程。

简单请求没问题

请求头携带origin字段， 响应头携带Access-Control-Allow-Origin: value, value是源地址或*都可以

复杂请求
复杂请求先分为这几类(可以从请求报文中分析记忆)
1. 除get,post以外的请求方法
2. 有自定义的请求头
3. Content-Type: 除三个值application/x-www-form-urlencoded、multipart/form-data、text/plain以外的

那么浏览器就会发送一个预检请求options请求, 目的我觉得就是说去检查服务器是否支持这些请求服务。

所以响应会携带这些字段

1. Access-Control-Allow-Methods: 支持的请求方法

2. Access-Control-Allow-Headers: 支持的自定义请求头

3. Access-Control-Max-Age: 该预检请求缓存时间

4. 还有跟cookie相关的 Access-Control-Allow-Credentials

服务器如果不返回 1和2这两个字段，浏览器就会认为服务器不同意预检请求，无法实现跨域访问。

**跨域cookie**

非同源服务器上，假如在http请求头上 设置了 Set-Cookie字段，它的确是存储到浏览器上的。

另外这一个不能忽略了，每个cookie都绑定在设置它的域名上。

那么下次cors访问时，我们需要在ajax上携带cookie。所以得设置withCredentials字段

日后 chrome在跨域cookie上需要设置一个SameSite=none 和 Secure 才能让请求携带cookie(具体可以看项目截图)


#### options请求在 79+ chrome版本上不再出现

值得一提的是，我昨天在实现过程中，发现到了这一点。

但我的服务器的确是有接收到options请求的，有打印在控制台中。

那原因搜了一下 大致上就是chrome79+ 以上版本不再打印，具体可以看这个链接 [Chrome 79+ no longer shows preflight CORS requests](https://httptoolkit.tech/blog/chrome-79-doesnt-show-cors-preflight)


#### 机器人行走的范围

问题: 机器人在mXn的矩阵内行走，每次只能走一步，只能上下左右走，限制条件就是 当前位置的数分位之和 < k

例如 此时的位置(10, 5), k是16。 1 + 0 + 5 < 16 所以这个位置是可以走的

那这题其实很简单，我用了BFS。具体思路就是，由若干个可能的当前位置，然后依次每个位置走向下一个位置，并统计总数。

把每个当前位置抽象成树的节点，的确这个就是BFS的思路。**而且我发现，其实往上走和往左走都是不必要的，因为这两个节点必然**

**已经走过了** ,那边界情况还是存在的，当前的几个节点可能会走到同一个节点上这里还是要处理下的。

所以我设置了一个mXn的record表用来记录已经走过的节点，避免重复。

#### 链表中有环为什么快指针步速不能是3或是其他的值(步速我指的是每次移动的节点数)

我的回答是，因为在特殊情况下，慢指针和快指针永远无法相遇。

假设快指针的步速是3节点/次， 满指针的步速是1节点/次。 那么它们两者的步速之差就是2节点/次

假设它们进入环时， 两指针相差n个节点，n是个奇数， m是环的长度。

**n / 2= 次数····1** 距离除以步速毫无疑问就是 需要的次数，但还是相差1个节点的距离

那么此时它们的距离就是 1 + m 或者说是 m -1这都行， 假设m是个偶数

**m+1 / 2= 次数····1** 可以看到距离仍差1个节点，那么这个情况就会一直重复下去。

换句话说，它们永远无法相遇

#### 通过新的标签页访问网络资源无法命中强缓存

#### 面试题57-和为s的连续正数序列

入参是 target， 然后要求是求连续的数列，这个数列和等于target

那刚开始的思路还是暴力枚举。

但过程中，我发现连续的数列，这不就是差为1的等差数列吗？那根据公示 n(a1 + an)/ 2 = target

根据题目条件 n这个项数，应当大于2。另外我们可以推得另外几个条件

1. a1 + an必然是正整数
2. 如果n是偶数 a1 + an 必然是奇数，反之， n是奇数 a1+ an是偶数
3. a1 + an 必然大于n

经过上述条件，我们就可以写出答案了

#### 解构复值和 扩展运算符

这个我有点遗忘了，所以这里记下。

```js
// 别名使用
var {a: aAlias} = b

// 数组使用
var [a, b] = array

// 扩展运算符 在对象中可以这样使用  假设a是对象
var b ={
  ...a
}
```

#### 解码方法总数

题目背景: 26个英文字母 映射成 从1开始的26个数字

例如: A -> 1, B -> 2, ...., Z -> 26

输入 '112', 输出 3 (种解码方法)

因为 112可以解码成 11 和 2也就是(KB), 也可以是 1 和 12 也就是(AL), 也可以是 1 和 1 和 2(AAB)

做了这么多动态规划题目，我觉得可以总结出来 类似像数组和字符串这种数据结构，都是通过某个位置的**状态**来推导最优子结构。

例如这一题，假设dp\[i] 代表i位置 解码方法总数, s是指输入的字符串

那么我们可以知道i位置的解码方法总数 和 前面i-1 和 i-2位置的解码方法总数是一定的关系的。

s\[i]位置代表的字符可能是0-9,

* 假设前一位是1或2， 分类讨论 可能的结果就是s\[i-1]+s\[i] 10-29
  1. 10和20是特殊情况，因为s\[i]不能单独解码 所以dp\[i] = dp\[i-1] 
  2. <= '26', 且s\[i] != '0', dp\[i] = dp\[i-1] + dp\[i-2], 既可以单独解码，又可以组合解码。
  3. \> '27' dp\[i] = dp\[i-1]

* 假设前一位不是(1或2)，不能组合解码
  1. 是0 则直接返回0 因为该位不能被解码
  2. 是1-9 则dp\[i] = dp\[i-1]

那边界情况就是dp\[0] 和 dp\[1]，因为按照上面的状态转移方程，dp\[1]可能出现数组访问越界的情况
